package org.lx.crawler;

import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.Date;

import org.lx.util.DigestUtil;

public class FileSnapShot extends AbstractSnapShot
{
	public final static String URL_ENCODE = "UTF-8";

	public final static String TEMP_EXT = ".tmp";

	protected String m_cacheId;

	DigestUtil m_digestUtil = null;

	String m_url;

	int m_ifile = 0;

	File m_file;

	int m_itmpeFile = 0;

	File m_tempFile;

	long m_csFileTimeStamp;

	public class LockedFileInputStream extends FileInputStream
	{
		File m_file;

		public LockedFileInputStream(File f) throws FileNotFoundException
		{
			super(f);
			m_file = f;
		}

		public void close() throws IOException
		{
			super.close();
			synchronized (m_file)
			{
				m_file.notify();
			}
		}
	}

	public FileSnapShot(ISnapShotManager sm, String cacheId)
	{
		super(sm);
		m_cacheId = cacheId;
	}

	public String getURL()
	{
		return m_url;
	}

	public FileSnapShot(ISnapShotManager sm, Request request)
	{
		super(sm);
		m_digestUtil = DigestUtil.getInstance();
		m_url = request.getURI();
		String cacheId = getSnapShotId(sm, request);
		m_cacheId = cacheId;
	}

	protected String getSnapShotId(ISnapShotManager cm, Request request)
	{
		String retval = null;
		try
		{
			// the MD5 is generated by the URL+POST body's UTF-8 bytes stream.
			StringBuffer sb = new StringBuffer();
			sb.append(request.hashCode());

			byte[] url_bytes = sb.toString().getBytes(URL_ENCODE);
			// MD5 for url's utf-8 encoding bytes.

			StringBuffer hexString = new StringBuffer();
			String cache_dir = cm.getSnapShotLocation();
			if (cache_dir != null)
			{
				hexString.append(cache_dir);
				String seq = System.getProperty("file.separator");
				if (cache_dir.endsWith(seq) == false)
				{
					hexString.append(seq);
				}
			}

			// Add the MD5 digest.
			hexString.append(m_digestUtil.md5(url_bytes));

			retval = hexString.toString();
		} catch (UnsupportedEncodingException e)
		{
			// UTF-8 must be support.
			e.printStackTrace();
		}
		return retval;
	}

	protected File getTempFile()
	{
		if (m_tempFile == null && m_cacheId != null)
		{
			m_tempFile = new File(m_cacheId + TEMP_EXT);
		}

		return m_tempFile;
	}

	protected File getSnapShotFile()
	{
		if (m_file == null && m_cacheId != null)
		{
			m_file = new File(m_cacheId);
		}

		// wait if the m_file be locked for update
		if (m_file != null)
		{
			synchronized (m_file)
			{
			}
		}
		return m_file;
	}

	/**
	 * get the SnapShot's InputStream for the specific URL.
	 * @param html_url
	 *        The Request URL.
	 * @param param
	 *        The Http request parameters.
	 * @return
	 */
	public InputStream getInputStream() throws IOException
	{
		InputStream retval = null;
		File f = getSnapShotFile();
		if (f != null && f.exists())
		{
			retval = new LockedFileInputStream(f);
		}
		return retval;
	}

	/**
	 * get the SnapShot's outputStream for the specific URL.
	 * @param html_url
	 *        The Request URL.
	 * @param param
	 *        The Http request parameters.
	 * @return
	 */
	public OutputStream getOutputStream() throws IOException
	{
		OutputStream retval = null;
		File f = getSnapShotFile();
		if (f != null)
		{
			retval = new FileOutputStream(f);
		}
		return retval;
	}

	/**
	 * get the temp cache's outputStream for the specific URL.
	 * @param html_url
	 *        The Request URL.
	 * @param param
	 *        The Http request parameters.
	 * @return
	 */
	protected OutputStream getTempOutputStream() throws IOException
	{
		File f = getTempFile();

		return new FileOutputStream(f);

	}

	synchronized protected void reloadSnapShotInfo() throws IOException
	{
		do
		{
			if (m_cacheId == null)
			{
				break;
			}
			File f = new File(m_cacheId + ".cs");
			if (!f.exists())
			{
				break;
			}

			if (m_csFileTimeStamp != f.lastModified())
			{
				m_snapShotInfo.read(new FileInputStream(f));
				m_csFileTimeStamp = f.lastModified();
			}
		} while (false);
	}

	/**
	 * remove the specific SnapShot.
	 * @param cacheId
	 * @return
	 */
	synchronized public void remove() throws IOException
	{
		if (m_cacheId != null)
		{
			File f = new File(m_cacheId);
			if (f.exists())
			{
				f.delete();
			}
			f = new File(m_cacheId + ".cs");
			if (f.exists())
			{
				f.delete();
			}
		}
	}

	/**
	 * check the SnapShot status, the damaged file will be deleted.
	 * @return
	 */
	public boolean checkIntegrity() throws IOException
	{
		boolean retval = true;
		do
		{
			if (m_cacheId == null)
			{
				break;
			}
			File f = new File(m_cacheId);
			File f_cs = new File(m_cacheId + ".cs");

			if (f.exists() && f_cs.exists())
			{
				// that is ok.
				break;
			}
			retval = false;
		} while (false);
		return retval;
	}

	/**
	 * get the SnapShot file's local create time.
	 * @return
	 */
	public long getSnapShotModified() throws IOException
	{
		long retval = 0;
		if (m_cacheId != null)
		{
			File f = new File(m_cacheId);
			retval = f.lastModified();
		}
		return retval;
	}

	protected void saveContentFile(InputStream in) throws IOException
	{
		do
		{
			// output to the temp file.
			File f = getTempFile();

			OutputStream out = getTempOutputStream();
			try
			{
				byte[] buf = new byte[512];
				int len = 0;
				// begin to write to the temp file to avoid more than one
				// thread to write to one file.
				synchronized (f)
				{
					try
					{
						while ((len = in.read(buf)) != -1)
						{
							out.write(buf, 0, len);
						}
					} catch (EOFException e)
					{

					}
					out.flush();
					out.close();
				}
				// rename to the SnapShot file.

				File snapShotFile = getSnapShotFile();
				if (snapShotFile == null)
				{
					break;
				}
				// synchronized for the SnapShot file.
				synchronized (this)
				{
					boolean success = true;
					int cnt = 0;
					// try to delete the original snapShotFile
					do
					{
						if (snapShotFile.exists())
						{
							success = snapShotFile.delete();
						}
						if (!success)
						{
							long t1 = new Date().getTime();
							try
							{
								// wait 3 seconds
								snapShotFile.wait(5 * 1000);
							} catch (InterruptedException e)
							{
								throw new IOException(
										"wait for delete old SnapShot:"
												+ (new Date().getTime() - t1));
							}
						}
						cnt++;
					} while (!success && cnt < 3);

					if (!success)
					{
						throw new IOException("Error when delete "
								+ snapShotFile.getName());
					}
					success = f.renameTo(snapShotFile);
					if (!success)
					{
						throw new IOException("Error when rename '"
								+ f.getName() + "' to "
								+ snapShotFile.getName());
					}
					m_file = null;
					m_tempFile = null;
				}
			} finally
			{
				out.close();
			}
		} while (false);
	}

	protected void saveThumbFile() throws IOException
	{
		File csFile = new File(m_cacheId + ".cs");
		FileOutputStream out = new FileOutputStream(csFile);

		try
		{
			synchronized (this)
			{
				m_snapShotInfo.write(out);
			}
		} finally
		{
			out.close();
		}
	}

	/**
	 * Save the snapshot, verify the parameters
	 */
	public void save(InputStream in) throws IOException
	{
		if (in != null)
		{
			saveContentFile(in);
		}
		saveThumbFile();
	}

	/**
	 * close the cache, buffer should be flush before close the the cache
	 * @throws IOException
	 */
	public void close() throws IOException
	{
		if (m_snapShotInfo != null)
		{
			FileOutputStream out = new FileOutputStream(m_cacheId);
			m_snapShotInfo.write(out);
		}
	}

}
